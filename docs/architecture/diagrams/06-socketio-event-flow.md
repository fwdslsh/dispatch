# Socket.IO Event Flow

This diagram illustrates the real-time bidirectional communication protocol between clients and server using Socket.IO, including authentication, session attachment, and event streaming.

```mermaid
sequenceDiagram
    participant Client as Web Client
    participant Socket as Socket.IO Server
    participant Auth as Auth Middleware
    participant SessionMgr as RunSessionManager
    participant Adapter as Session Adapter
    participant DB as Database

    Note over Client,DB: Connection & Authentication

    Client->>Socket: connect()
    Socket->>Auth: validate cookie/apiKey
    Auth->>DB: lookup session/key
    DB-->>Auth: user data
    Auth-->>Socket: user authenticated
    Socket-->>Client: connected

    Note over Client,DB: Client Identification

    Client->>Socket: client:hello {clientId}
    Socket->>SessionMgr: register client
    SessionMgr-->>Socket: acknowledged
    Socket-->>Client: client:hello:ack

    Note over Client,DB: Session Attachment & Replay

    Client->>Socket: run:attach {runId, fromSeq}
    Socket->>SessionMgr: attach(runId, clientId, fromSeq)
    SessionMgr->>DB: SELECT * FROM session_events<br/>WHERE run_id=? AND seq>=?
    DB-->>SessionMgr: historical events
    SessionMgr-->>Socket: replay events [seq 1..N]
    Socket-->>Client: run:event (multiple)
    SessionMgr->>Adapter: subscribe client to live events
    Adapter-->>SessionMgr: client subscribed

    Note over Client,DB: Real-time Session Input

    Client->>Socket: run:input {runId, data}
    Socket->>SessionMgr: handleInput(runId, data)
    SessionMgr->>Adapter: input(data)
    Adapter->>Adapter: process input

    Note over Client,DB: Real-time Session Events

    Adapter->>SessionMgr: emit({channel, type, payload})
    SessionMgr->>SessionMgr: assign sequence number
    SessionMgr->>DB: INSERT INTO session_events<br/>(runId, seq, channel, type, payload)
    DB-->>SessionMgr: event persisted
    SessionMgr->>Socket: broadcast run:event<br/>{runId, seq, channel, type, payload}
    Socket-->>Client: run:event (to all attached clients)

    Note over Client,DB: Session Termination

    Client->>Socket: run:close {runId}
    Socket->>SessionMgr: close(runId)
    SessionMgr->>Adapter: close()
    Adapter->>Adapter: cleanup resources
    Adapter-->>SessionMgr: closed
    SessionMgr->>DB: UPDATE sessions<br/>SET status='closed'
    SessionMgr->>Socket: run:event {type: 'closed'}
    Socket-->>Client: run:event {type: 'closed'}

    Note over Client,DB: Session Expiration

    Auth->>Auth: session expired
    Auth->>Socket: emit session:expired
    Socket-->>Client: session:expired
    Client->>Client: redirect to login
```

## Event Protocol

### Client → Server Events

#### client:hello
```javascript
{
  clientId: "browser-fingerprint-uuid"
}
```
- **Purpose**: Identify client for multi-tab support
- **Response**: `client:hello:ack`
- **Required**: First event after connection

#### run:attach
```javascript
{
  runId: "session-uuid",
  fromSeq: 0  // sequence number to start replay from
}
```
- **Purpose**: Attach to existing session and replay missed events
- **Response**: Multiple `run:event` messages (historical) followed by live stream
- **Replay**: Events sent in order from `fromSeq` to current
- **Use Cases**: Initial load, reconnect after disconnect, multi-tab sync

#### run:input
```javascript
{
  runId: "session-uuid",
  data: "user input string"
}
```
- **Purpose**: Send user input to session (keystrokes, commands, etc.)
- **Target**: Routed to appropriate adapter based on session type
- **No Response**: Events generated by adapter as result of input

#### run:close
```javascript
{
  runId: "session-uuid"
}
```
- **Purpose**: Terminate session
- **Effect**: Adapter cleanup, database update, final events emitted
- **Response**: `run:event` with type 'closed'

### Server → Client Events

#### run:event
```javascript
{
  runId: "session-uuid",
  seq: 42,  // monotonic sequence number
  channel: "stdout",  // stdout, stderr, status, custom
  type: "data",       // channel-specific event type
  payload: {          // event-specific data
    text: "output text"
  },
  timestamp: "2024-01-15T10:30:00Z"
}
```
- **Purpose**: Stream session activity to clients
- **Guarantee**: Events delivered in sequence order
- **Persistence**: All events logged to database
- **Channels**:
  - `stdout`: Standard output data
  - `stderr`: Error output data
  - `status`: Session lifecycle events (started, closed, error)
  - Custom channels per adapter

#### session:expired
```javascript
{
  message: "Your session has expired. Please log in again."
}
```
- **Purpose**: Notify client of authentication expiration
- **Action**: Client should redirect to login page
- **Trigger**: Session timeout, logout from another tab, key disabled

## Multi-Client Synchronization

### Scenario: Multiple Tabs Viewing Same Session

```mermaid
sequenceDiagram
    participant Tab1 as Tab 1
    participant Tab2 as Tab 2
    participant Server as Socket.IO Server

    Tab1->>Server: run:attach {runId, fromSeq: 0}
    Server-->>Tab1: run:event [1..10]

    Note over Tab1,Server: Tab 1 fully synced to seq 10

    Tab1->>Server: run:input {runId, "ls"}
    Server-->>Tab1: run:event {seq: 11, data: "file1.txt"}
    Server-->>Tab1: run:event {seq: 12, data: "file2.txt"}

    Note over Tab2: User opens new tab

    Tab2->>Server: run:attach {runId, fromSeq: 0}
    Server-->>Tab2: run:event [1..12] (replay all)

    Note over Tab1,Tab2: Both tabs in sync at seq 12

    Tab2->>Server: run:input {runId, "pwd"}
    Server-->>Tab1: run:event {seq: 13, data: "/workspace"}
    Server-->>Tab2: run:event {seq: 13, data: "/workspace"}
```

### Reconnection After Network Failure

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: connected, run:attach {fromSeq: 0}
    Server-->>Client: run:event [1..10]

    Note over Client,Server: Network interruption

    Client->>Client: disconnect detected<br/>last received seq: 10

    Note over Client,Server: Network restored

    Client->>Server: reconnect, run:attach {fromSeq: 11}
    Server-->>Client: run:event [11..15] (catchup)

    Note over Client: Client now in sync, no data lost
```

## Event Channels

### stdout Channel
```javascript
{
  channel: "stdout",
  type: "data",
  payload: {
    text: "command output"
  }
}
```

### stderr Channel
```javascript
{
  channel: "stderr",
  type: "error",
  payload: {
    text: "error message"
  }
}
```

### status Channel
```javascript
{
  channel: "status",
  type: "started",
  payload: {
    sessionType: "pty",
    metadata: {...}
  }
}

{
  channel: "status",
  type: "closed",
  payload: {
    exitCode: 0,
    reason: "user_requested"
  }
}
```

### Custom Channels (Adapter-specific)
```javascript
// Claude adapter example
{
  channel: "claude",
  type: "thinking",
  payload: {
    content: "analyzing code..."
  }
}

// File editor example
{
  channel: "file",
  type: "saved",
  payload: {
    path: "/workspace/file.txt",
    size: 1024
  }
}
```

## Error Handling

### Connection Errors
- **Retry Logic**: Exponential backoff (1s, 2s, 4s, 8s, max 30s)
- **User Notification**: Toast/banner showing connection status
- **State Preservation**: Client maintains last sequence number for resume

### Authentication Errors
- **Invalid Credentials**: Close connection, redirect to login
- **Session Expired**: Emit `session:expired`, redirect to login
- **Rate Limiting**: Temporary connection block with retry-after

### Session Errors
- **Session Not Found**: Return error event, close socket
- **Adapter Crash**: Emit error event, mark session as error state
- **Database Error**: Log error, attempt retry, fallback to error state

## Performance Considerations

### Event Batching
- Events emitted individually for real-time feel
- Database writes can be batched for performance (configurable)
- Large payloads (>1MB) should use alternative transfer method

### Scalability
- Each Socket.IO connection is lightweight
- Sessions isolated (no shared state between sessions)
- Database connection pooling for concurrent access
- Horizontal scaling possible with Redis adapter (future)

### Monitoring
- Track event counts per session
- Monitor sequence number gaps (data loss detection)
- Alert on high latency between event generation and delivery
