/**
 * SettingsViewModel - Svelte 5 State Management
 * Manages settings state with reactive $state runes and MVVM pattern
 */

/**
 * Settings category structure
 * @typedef {Object} SettingsCategory
 * @property {string} id - Category ID
 * @property {string} name - Display name
 * @property {string} description - Category description
 * @property {number} display_order - Display order
 */

/**
 * Configuration setting structure
 * @typedef {Object} ConfigurationSetting
 * @property {string} key - Setting key
 * @property {string} category_id - Category ID
 * @property {string} name - Display name
 * @property {string} description - Description
 * @property {string} type - Setting type
 * @property {string|null} current_value - Current value
 * @property {string|null} default_value - Default value
 * @property {string|null} env_var_name - Environment variable name
 * @property {boolean} is_sensitive - Whether to mask in UI
 * @property {boolean} is_required - Whether required
 * @property {string|null} validation_pattern - Validation regex
 * @property {string|null} resolved_value - Resolved value
 * @property {string|null} display_value - Display-safe value
 */

export class SettingsViewModel {
	/**
	 * Create SettingsViewModel instance
	 * @param {Object} settingsService - Settings API service
	 */
	constructor(settingsService) {
		this.settingsService = settingsService;

		// Reactive state using Svelte 5 $state runes
		this.categories = $state([]);
		this.settings = $state([]);
		this.loading = $state(false);
		this.saving = $state(false);
		this.error = $state(null);
		this.successMessage = $state(null);
		// Use plain objects instead of Maps for reactivity
		this.validationErrors = $state({});
		this.pendingChanges = $state({});
		this.authConfig = $state({
			terminal_key_set: false,
			oauth_configured: false,
			oauth_client_id: null,
			oauth_redirect_uri: null
		});

		// Derived state
		this.settingsByCategory = $derived.by(() => {
			if (!this.categories || !Array.isArray(this.categories)) {
				return [];
			}
			return this.categories.map((category) => ({
				...category,
				settings: this.settings.filter((setting) => setting.category_id === category.id)
			}));
		});

		this.settingsByKey = $derived.by(() => {
			const map = new Map();
			this.settings.forEach((setting) => {
				map.set(setting.key, setting);
			});
			return map;
		});

		this.hasUnsavedChanges = $derived.by(() => {
			return Object.keys(this.pendingChanges).length > 0;
		});

		this.hasValidationErrors = $derived.by(() => {
			return Object.keys(this.validationErrors).length > 0;
		});

		this.canSave = $derived.by(() => {
			return this.hasUnsavedChanges && !this.hasValidationErrors && !this.saving;
		});

		// Derived computed property for authentication settings
		this.authenticationSettings = $derived.by(() => {
			return this.settings.filter((s) => s.category_id === 'authentication');
		});
	}

	/**
	 * Get a setting by key
	 * @param {string} key - Setting key
	 * @returns {ConfigurationSetting|undefined} Setting object
	 */
	getSetting(key) {
		return this.settings.find((s) => s.key === key);
	}

	/**
	 * Get all settings for a category
	 * @param {string} categoryId - Category ID
	 * @returns {ConfigurationSetting[]} Array of settings
	 */
	getSettingsByCategory(categoryId) {
		return this.settings.filter((s) => s.category_id === categoryId);
	}

	/**
	 * Load all settings from the API
	 * @param {string|null} categoryFilter - Optional category to filter by
	 */
	async loadSettings(categoryFilter = null) {
		this.loading = true;
		this.error = null;

		try {
			const result = await this.settingsService.getAllSettings(categoryFilter);

			// API returns categorized structure: { claude: {...}, workspace: {...}, ... }
			// Transform to internal format for UI
			const categories = [];
			const settings = [];

			// Process each category from the API response
			for (const [categoryId, categoryData] of Object.entries(result)) {
				// Create category metadata
				categories.push({
					id: categoryId,
					name: this._getCategoryDisplayName(categoryId),
					description: this._getCategoryDescription(categoryId),
					display_order: this._getCategoryOrder(categoryId)
				});

				// Flatten category settings for UI representation
				// Handle both simple values and nested objects
				this._flattenSettings(categoryId, categoryData, '', settings);
			}

			this.categories = categories;
			this.settings = settings;

			// Clear pending changes when loading fresh data
			this.pendingChanges = {};
			this.validationErrors = {};
		} catch (error) {
			console.error('Failed to load settings:', error);
			this.error = 'Failed to load settings. Please try again.';
		} finally {
			this.loading = false;
		}
	}

	/**
	 * Recursively flatten nested settings into UI-friendly format
	 * @param {string} categoryId - Category ID
	 * @param {any} data - Settings data (object, array, or primitive)
	 * @param {string} path - Current path (e.g., 'envVariables.NODE_ENV')
	 * @param {Array} settings - Output array to populate
	 */
	_flattenSettings(categoryId, data, path, settings) {
		if (data === null || data === undefined) {
			// Store null/undefined as-is
			const key = path || categoryId;
			settings.push(this._createSettingObject(categoryId, key, data));
			return;
		}

		if (typeof data === 'object' && !Array.isArray(data)) {
			// Handle objects
			const entries = Object.entries(data);

			if (entries.length === 0) {
				// Empty object - store as-is (e.g., workspace.envVariables = {})
				const key = path || categoryId;
				settings.push(this._createSettingObject(categoryId, key, data));
			} else {
				// Recurse into nested properties
				for (const [key, value] of entries) {
					const newPath = path ? `${path}.${key}` : key;
					this._flattenSettings(categoryId, value, newPath, settings);
				}
			}
		} else if (Array.isArray(data)) {
			// Handle arrays - store as JSON string for editing
			const key = path || categoryId;
			settings.push(this._createSettingObject(categoryId, key, data));
		} else {
			// Primitive values (string, number, boolean)
			const key = path || categoryId;
			settings.push(this._createSettingObject(categoryId, key, data));
		}
	}

	/**
	 * Create a setting object for UI display
	 * @param {string} categoryId - Category ID
	 * @param {string} key - Setting key (may include dots for nested paths)
	 * @param {any} value - Setting value
	 * @returns {Object} Setting object
	 */
	_createSettingObject(categoryId, key, value) {
		return {
			key, // Full dotted path, e.g., 'envVariables.NODE_ENV' or just 'model'
			category_id: categoryId,
			display_name: this._getSettingDisplayName(key),
			description: this._getSettingDescription(key),
			type: this._inferSettingType(key, value),
			current_value: value,
			default_value: value,
			env_var_name: this._getEnvVarName(key),
			is_sensitive: this._isSettingSensitive(key),
			is_required: this._isSettingRequired(key),
			validation_pattern: null,
			resolved_value: value,
			display_value: this._getDisplayValue(key, value),
			options: this._getSettingOptions(key),
			placeholder: this._getSettingPlaceholder(key)
		};
	}

	/**
	 * Helper methods for transforming API data to UI-friendly format
	 */
	_getCategoryDisplayName(categoryId) {
		const names = {
			workspace: 'Workspace',
			ui: 'UI',
			system: 'System',
			authentication: 'Authentication'
		};
		return names[categoryId] || categoryId;
	}

	_getCategoryDescription(categoryId) {
		const descriptions = {
			workspace: 'Workspace and project settings',
			ui: 'User interface preferences',
			system: 'System configuration',
			authentication: 'Authentication and security settings'
		};
		return descriptions[categoryId] || '';
	}

	_getCategoryOrder(categoryId) {
		const order = {
			workspace: 1,
			ui: 2,
			system: 3,
			authentication: 4
		};
		return order[categoryId] || 99;
	}

	_getSettingDisplayName(key) {
		// Convert snake_case or camelCase to Title Case
		return key
			.replace(/([A-Z])/g, ' $1')
			.replace(/_/g, ' ')
			.split(' ')
			.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
			.join(' ')
			.trim();
	}

	_getSettingDescription(key) {
		const descriptions = {
			workspaces_root: 'Default root directory for workspaces',
			terminal_key: 'Authentication key for terminal access (minimum 8 characters)',
			theme: 'Application color theme',
			show_workspace_in_title: 'Display current workspace name in browser title bar',
			auto_hide_inactive_tabs_minutes: 'Minutes of inactivity before hiding tabs (0 to disable)',
			default_workspace_path: 'Default path for new workspaces',
			session_duration_days: 'Number of days before authentication sessions expire'
		};
		return descriptions[key] || '';
	}

	_inferSettingType(key, value) {
		if (typeof value === 'boolean') return 'BOOLEAN';
		if (typeof value === 'number') return 'NUMBER';
		if (Array.isArray(value)) return 'ARRAY';
		if (typeof value === 'object' && value !== null) return 'JSON';
		if (key.includes('path') || key.includes('root') || key.includes('directory')) return 'PATH';
		if (key.includes('url')) return 'URL';
		return 'STRING';
	}

	_getEnvVarName(key) {
		// Map setting keys to environment variable names
		const envMap = {
			workspaces_root: 'WORKSPACES_ROOT',
			terminal_key: 'TERMINAL_KEY',
			port: 'PORT'
		};
		return envMap[key] || null;
	}

	_isSettingSensitive(key) {
		const sensitiveKeys = ['terminal_key', 'oauth_client_secret', 'api_key', 'password'];
		return sensitiveKeys.some((sensitive) => key.toLowerCase().includes(sensitive));
	}

	_isSettingRequired(key) {
		const requiredKeys = ['terminal_key', 'workspaces_root'];
		return requiredKeys.includes(key);
	}

	_getDisplayValue(key, value) {
		// Mask sensitive values
		if (this._isSettingSensitive(key) && value) {
			return '••••••••';
		}

		// Handle complex types for display
		if (typeof value === 'object') {
			if (value === null) return 'null';
			if (Array.isArray(value)) {
				// Display arrays as comma-separated for editing
				return value.join(', ');
			}
			// Display objects as formatted JSON
			return JSON.stringify(value, null, 2);
		}

		return value;
	}

	_getSettingOptions(key) {
		// Return select options for settings with predefined choices
		const optionsMap = {
			theme: [
				{ value: 'dark', label: 'Dark' },
				{ value: 'light', label: 'Light' },
				{ value: 'auto', label: 'Auto' }
			]
		};
		return optionsMap[key] || null;
	}

	_getSettingPlaceholder(key) {
		const placeholders = {
			workspaces_root: '/workspace',
			terminal_key: 'Enter a secure key (min 8 characters)',
			default_workspace_path: '/workspace/default',
			auto_hide_inactive_tabs_minutes: '30'
		};
		return placeholders[key] || '';
	}

	/**
	 * Load authentication configuration
	 */
	async loadAuthConfig() {
		try {
			const config = await this.settingsService.getAuthConfig();
			this.authConfig = config;
		} catch (error) {
			console.error('Failed to load auth config:', error);
			this.error = 'Failed to load authentication configuration.';
		}
	}

	/**
	 * Update a setting value
	 * @param {string} key - Setting key
	 * @param {string} value - New value
	 */
	updateSetting(key, value) {
		const setting = this.settingsByKey.get(key);
		if (!setting) {
			console.error(`Setting '${key}' not found`);
			return;
		}

		// Store pending change - create new object for reactivity
		this.pendingChanges = { ...this.pendingChanges, [key]: value };

		// Validate the new value
		this.validateSetting(key, value);

		// Clear success message when making changes
		this.successMessage = null;
	}

	/**
	 * Validate a setting value
	 * @param {string} key - Setting key
	 * @param {string} value - Value to validate
	 */
	validateSetting(key, value) {
		const setting = this.settingsByKey.get(key);
		if (!setting) return;

		const errors = [];
		const displayName = setting.display_name || setting.name || key;

		// Required validation
		if (setting.is_required && (!value || value.trim().length === 0)) {
			errors.push(`${displayName} is required`);
		}

		// Type-specific validation
		if (value && value.trim().length > 0) {
			switch (setting.type) {
				case 'NUMBER':
					if (isNaN(Number(value))) {
						errors.push(`${displayName} must be a valid number`);
					}
					break;
				case 'BOOLEAN':
					if (!['true', 'false', '1', '0', 'yes', 'no'].includes(value.toLowerCase())) {
						errors.push(`${displayName} must be a boolean value`);
					}
					break;
				case 'URL':
					try {
						new URL(value);
					} catch {
						errors.push(`${displayName} must be a valid URL`);
					}
					break;
				case 'PATH':
					if (!value.startsWith('/')) {
						errors.push(`${displayName} must be an absolute path`);
					}
					break;
			}

			// Pattern validation
			if (setting.validation_pattern) {
				try {
					const regex = new RegExp(setting.validation_pattern);
					if (!regex.test(value)) {
						errors.push(`${displayName} does not match the required format`);
					}
				} catch {
					errors.push(`Invalid validation pattern for ${displayName}`);
				}
			}

			// Special validations
			if (key === 'terminal_key' && value.length < 8) {
				errors.push('Terminal key must be at least 8 characters long');
			}
		}

		// Update validation errors - create new object for reactivity
		if (errors.length > 0) {
			this.validationErrors = { ...this.validationErrors, [key]: errors };
		} else {
			const { [key]: _, ...rest } = this.validationErrors;
			this.validationErrors = rest;
		}
	}

	/**
	 * Get current value for a setting (including pending changes)
	 * @param {string} key - Setting key
	 * @returns {string} Current value
	 */
	getCurrentValue(key) {
		// Check for pending changes first
		if (key in this.pendingChanges) {
			return this.pendingChanges[key];
		}

		// Get from current setting
		const setting = this.settingsByKey.get(key);
		return setting?.display_value || setting?.resolved_value || '';
	}

	/**
	 * Get validation errors for a setting
	 * @param {string} key - Setting key
	 * @returns {Array<string>} Validation errors
	 */
	getValidationErrors(key) {
		return this.validationErrors[key] || [];
	}

	/**
	 * Save settings for a category
	 * @param {string} categoryId - Category ID
	 */
	async saveCategory(categoryId) {
		const categoryChanges = {};

		// Collect changes for this category and reconstruct nested structure
		for (const [key, value] of Object.entries(this.pendingChanges)) {
			const setting = this.settingsByKey.get(key);
			if (setting?.category_id === categoryId) {
				// Reconstruct nested structure from flat keys
				// e.g., 'envVariables.NODE_ENV' -> { envVariables: { NODE_ENV: value } }
				this._setNestedValue(categoryChanges, key, value);
			}
		}

		if (Object.keys(categoryChanges).length === 0) {
			return;
		}

		// Check for validation errors in this category
		const categoryErrors = [];
		for (const key of Object.keys(this.pendingChanges)) {
			const setting = this.settingsByKey.get(key);
			if (setting?.category_id === categoryId) {
				const errors = this.getValidationErrors(key);
				if (errors.length > 0) {
					categoryErrors.push(...errors);
				}
			}
		}

		if (categoryErrors.length > 0) {
			this.error = 'Please fix validation errors before saving.';
			return;
		}

		this.saving = true;
		this.error = null;

		try {
			const result = await this.settingsService.updateCategorySettings(categoryId, categoryChanges);

			// Handle session invalidation warning
			if (result.session_invalidated) {
				this.successMessage =
					'Settings saved successfully. All sessions have been invalidated for security.';
			} else {
				this.successMessage = 'Settings saved successfully.';
			}

			// Remove saved changes from pending - create new object
			const newPending = { ...this.pendingChanges };
			for (const key of Object.keys(this.pendingChanges)) {
				const setting = this.settingsByKey.get(key);
				if (setting?.category_id === categoryId) {
					delete newPending[key];
				}
			}
			this.pendingChanges = newPending;

			// Reload settings to get updated values
			await this.loadSettings();

			// If authentication category was updated, reload auth config
			if (categoryId === 'authentication') {
				await this.loadAuthConfig();
			}
		} catch (error) {
			console.error('Failed to save settings:', error);
			this.error = error.message || 'Failed to save settings. Please try again.';
		} finally {
			this.saving = false;
		}
	}

	/**
	 * Set a nested value in an object using dot notation
	 * @param {Object} obj - Target object
	 * @param {string} path - Dot-separated path (e.g., 'envVariables.NODE_ENV')
	 * @param {any} value - Value to set
	 */
	_setNestedValue(obj, path, value) {
		const parts = path.split('.');
		let current = obj;

		for (let i = 0; i < parts.length - 1; i++) {
			const part = parts[i];
			if (!(part in current)) {
				current[part] = {};
			}
			current = current[part];
		}

		current[parts[parts.length - 1]] = value;
	}

	/**
	 * Save all pending changes
	 */
	async saveAll() {
		if (!this.hasUnsavedChanges) {
			return;
		}

		// Group changes by category
		const changesByCategory = {};
		for (const [key, value] of Object.entries(this.pendingChanges)) {
			const setting = this.settingsByKey.get(key);
			if (setting) {
				if (!changesByCategory[setting.category_id]) {
					changesByCategory[setting.category_id] = {};
				}
				changesByCategory[setting.category_id][key] = value;
			}
		}

		// Save each category
		for (const categoryId of Object.keys(changesByCategory)) {
			await this.saveCategory(categoryId);

			// Stop if there was an error
			if (this.error) {
				break;
			}
		}
	}

	/**
	 * Discard all pending changes
	 */
	discardChanges() {
		this.pendingChanges = {};
		this.validationErrors = {};
		this.error = null;
		this.successMessage = null;
	}

	/**
	 * Discard changes for a specific setting
	 * @param {string} key - Setting key
	 */
	discardSetting(key) {
		const { [key]: _, ...restPending } = this.pendingChanges;
		const { [key]: __, ...restErrors } = this.validationErrors;
		this.pendingChanges = restPending;
		this.validationErrors = restErrors;
	}

	/**
	 * Clear all messages
	 */
	clearMessages() {
		this.error = null;
		this.successMessage = null;
	}

	/**
	 * Check if a setting has unsaved changes
	 * @param {string} key - Setting key
	 * @returns {boolean} Whether setting has changes
	 */
	hasChanges(key) {
		return key in this.pendingChanges;
	}

	/**
	 * Check if a category has unsaved changes
	 * @param {string} categoryId - Category ID
	 * @returns {boolean} Whether category has changes
	 */
	categoryHasChanges(categoryId) {
		for (const key of Object.keys(this.pendingChanges)) {
			const setting = this.settingsByKey.get(key);
			if (setting?.category_id === categoryId) {
				return true;
			}
		}
		return false;
	}
}
