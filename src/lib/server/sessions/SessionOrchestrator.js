/**
 * SessionOrchestrator - Session lifecycle coordinator
 * @file Coordinates session lifecycle using repositories and adapters
 *
 * v3.0 Architecture: OpenCode-first with ephemeral windows
 * - AI sessions: Persisted to DB, event-sourced
 * - Terminal/File windows: Ephemeral (in-memory only), no DB persistence
 */

// eslint-disable-next-line no-unused-vars -- Needed for JSDoc type annotations
import { SessionRepository } from '../database/SessionRepository.js';
// eslint-disable-next-line no-unused-vars -- Needed for JSDoc type annotations
import { AdapterRegistry } from './AdapterRegistry.js';
// eslint-disable-next-line no-unused-vars -- Needed for JSDoc type annotations
import { EventRecorder } from './EventRecorder.js';
import { logger } from '../shared/utils/logger.js';
import { getActiveSocketIO } from '../shared/socket-setup.js';
import { isEphemeralSessionType, normalizeSessionType } from '../../shared/session-types.js';

export class SessionOrchestrator {
	#sessionRepository;
	#eventRecorder;
	#adapterRegistry;
	#activeSessions = new Map(); // sessionId -> { adapter, process, kind, isEphemeral }
	#ephemeralBuffers = new Map(); // sessionId -> { outputBuffer: [], maxLines: 10000 }

	/**
	 * @param {SessionRepository} sessionRepository - Session metadata repository
	 * @param {EventRecorder} eventRecorder - Event recorder
	 * @param {AdapterRegistry} adapterRegistry - Adapter registry
	 */
	constructor(sessionRepository, eventRecorder, adapterRegistry) {
		if (!sessionRepository) {
			throw new Error('SessionRepository is required');
		}
		if (!eventRecorder) {
			throw new Error('EventRecorder is required');
		}
		if (!adapterRegistry) {
			throw new Error('AdapterRegistry is required');
		}

		this.#sessionRepository = sessionRepository;
		this.#eventRecorder = eventRecorder;
		this.#adapterRegistry = adapterRegistry;
	}

	/**
	 * Create new session with event buffering
	 * For ephemeral sessions (terminal, file-editor): No DB persistence, in-memory only
	 * For persistent sessions (ai): Full DB persistence and event sourcing
	 *
	 * @param {string} kind - Session type (terminal, ai, file-editor)
	 * @param {Object} options - Session options
	 * @param {string} options.workspacePath - Workspace path (cwd)
	 * @param {Object} [options.metadata] - Additional metadata
	 * @param {string} [options.ownerUserId] - Owner user ID
	 * @returns {Promise<Object>} Created session
	 */
	async createSession(kind, options) {
		const normalizedKind = normalizeSessionType(kind);
		const isEphemeral = isEphemeralSessionType(normalizedKind);
		const { workspacePath, metadata = {}, ownerUserId = null, ...adapterOptions } = options;

		// Generate session ID
		const sessionId = isEphemeral
			? `${normalizedKind}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
			: null; // Will be generated by repository for persistent sessions

		let session;

		if (isEphemeral) {
			// Ephemeral session: No DB persistence
			session = {
				id: sessionId,
				kind: normalizedKind,
				status: 'starting',
				workspacePath: workspacePath || metadata.cwd,
				metadata,
				createdAt: Date.now(),
				isEphemeral: true
			};

			// Initialize output buffer for terminal sessions
			if (normalizedKind === 'terminal') {
				this.#ephemeralBuffers.set(sessionId, {
					outputBuffer: [],
					maxLines: 10000 // Keep last 10K lines in memory
				});
			}

			logger.info('SESSION', `Creating ephemeral ${normalizedKind} window: ${sessionId}`);
		} else {
			// Persistent session: Full DB persistence
			session = await this.#sessionRepository.create({
				kind: normalizedKind,
				workspacePath,
				metadata,
				ownerUserId
			});
			logger.info('SESSION', `Creating persistent ${normalizedKind} session: ${session.id}`);
		}

		let adapter = null;
		let process = null;
		let cleanupRequired = false;

		try {
			// Only use event buffering for persistent sessions
			if (!isEphemeral) {
				this.#eventRecorder.startBuffering(session.id);
				cleanupRequired = true;
			}

			// Get adapter
			adapter = this.#adapterRegistry.getAdapter(normalizedKind);

			// Create process with onEvent callback
			process = await adapter.create({
				...adapterOptions,
				...metadata,
				onEvent: (ev) => {
					if (isEphemeral) {
						// Ephemeral: Buffer in memory, emit directly to socket
						this.#handleEphemeralEvent(session.id, normalizedKind, ev);
					} else {
						// Persistent: Use EventRecorder for DB persistence
						this.#eventRecorder.recordEvent(session.id, ev).catch((err) => {
							logger.error('SESSION', `Event recording failed for ${session.id}:`, err);
						});
					}
				}
			});

			// Store active session
			this.#activeSessions.set(session.id, {
				adapter,
				process,
				kind: normalizedKind,
				isEphemeral,
				cwd: workspacePath || metadata.cwd
			});

			if (!isEphemeral) {
				// Flush buffered events for persistent sessions
				await this.#eventRecorder.flushBuffer(session.id);
				// Update status in DB
				await this.#sessionRepository.updateStatus(session.id, 'running');
			}

			// Successfully initialized - no cleanup needed
			cleanupRequired = false;
			session.status = 'running';

			logger.info(
				'SESSION',
				`Created ${isEphemeral ? 'ephemeral' : 'persistent'} ${normalizedKind} session: ${session.id}`
			);

			return session;
		} catch (error) {
			logger.error('SESSION', `Failed to create ${normalizedKind} session ${session.id}:`, error);
			throw error;
		} finally {
			// Cleanup on error
			if (cleanupRequired) {
				await this.#safeCleanup(session.id, process, isEphemeral);
			}
		}
	}

	/**
	 * Handle events for ephemeral sessions (in-memory buffer + direct socket emit)
	 * @param {string} sessionId - Session ID
	 * @param {string} kind - Session kind
	 * @param {Object} event - Event data
	 */
	#handleEphemeralEvent(sessionId, kind, event) {
		// Buffer output for terminal sessions
		if (kind === 'terminal' && event.channel === 'pty:stdout') {
			const buffer = this.#ephemeralBuffers.get(sessionId);
			if (buffer) {
				buffer.outputBuffer.push({
					...event,
					ts: Date.now()
				});
				// Trim to max lines
				if (buffer.outputBuffer.length > buffer.maxLines) {
					buffer.outputBuffer = buffer.outputBuffer.slice(-buffer.maxLines);
				}
			}
		}

		// Emit directly to socket room
		try {
			const io = getActiveSocketIO();
			if (io) {
				io.to(`run:${sessionId}`).emit('run:event', {
					runId: sessionId,
					seq: Date.now(), // Use timestamp as pseudo-sequence for ephemeral
					...event,
					ts: Date.now()
				});
			}
		} catch (error) {
			logger.error('SESSION', `Failed to emit ephemeral event for ${sessionId}:`, error);
		}
	}

	/**
	 * Get buffered output for an ephemeral terminal session
	 * @param {string} sessionId - Session ID
	 * @returns {Array} Buffered output events
	 */
	getEphemeralBuffer(sessionId) {
		const buffer = this.#ephemeralBuffers.get(sessionId);
		return buffer?.outputBuffer || [];
	}

	/**
	 * Attach to existing session
	 * For ephemeral sessions: Returns buffered output from memory
	 * For persistent sessions: Returns events from DB
	 *
	 * @param {string} sessionId - Session ID
	 * @param {number} [fromSeq=0] - Starting sequence number for replay
	 * @returns {Promise<{session: Object, events: Array, process: Object|null}>} Session and events
	 */
	async attachToSession(sessionId, fromSeq = 0) {
		// Check if it's an active session first (works for both ephemeral and persistent)
		const activeSession = this.#activeSessions.get(sessionId);

		if (activeSession?.isEphemeral) {
			// Ephemeral session: Return buffered output from memory
			const events = this.getEphemeralBuffer(sessionId);
			const session = {
				id: sessionId,
				kind: activeSession.kind,
				status: 'running',
				cwd: activeSession.cwd,
				isEphemeral: true
			};
			return { session, events, process: activeSession.process };
		}

		// Persistent session: Get from database
		const session = await this.#sessionRepository.findById(sessionId);
		if (!session) {
			throw new Error(`Session not found: ${sessionId}`);
		}

		// Get events since sequence number (use EventRecorder method)
		const events = await this.#eventRecorder.getEvents(sessionId, fromSeq);

		if (activeSession) {
			return { session, events, process: activeSession.process };
		}

		return { session, events, process: null };
	}

	/**
	 * Send input to session
	 * For ephemeral sessions: Just sends to process (no event recording)
	 * For persistent sessions: Sends to process and records event
	 *
	 * @param {string} sessionId - Session ID
	 * @param {string} input - Input data
	 * @returns {Promise<void>}
	 */
	async sendInput(sessionId, input) {
		const active = this.#activeSessions.get(sessionId);
		if (!active) {
			throw new Error(`Session not active: ${sessionId}`);
		}

		const { process, isEphemeral } = active;

		// Standard interface: process.input?.write()
		if (!process.input?.write) {
			throw new Error(`Session ${sessionId} does not support input`);
		}

		process.input.write(input);

		// Only record input events for persistent sessions
		if (!isEphemeral) {
			await this.#eventRecorder.recordEvent(sessionId, {
				channel: 'system:input',
				type: 'input',
				payload: { data: input }
			});
		}
	}

	/**
	 * Close session
	 * For ephemeral sessions: Just closes process and clears memory
	 * For persistent sessions: Updates DB status and clears event buffers
	 *
	 * @param {string} sessionId - Session ID
	 * @returns {Promise<void>}
	 */
	async closeSession(sessionId) {
		const errors = [];
		const activeSession = this.#activeSessions.get(sessionId);
		const isEphemeral = activeSession?.isEphemeral ?? false;

		if (activeSession) {
			const { process } = activeSession;

			// Close process
			try {
				if (typeof process.close === 'function') {
					process.close();
				}
			} catch (error) {
				errors.push({ operation: 'process.close', error });
				logger.warn('SESSION', `Error closing process for ${sessionId}:`, error.message);
			}

			// Remove from active sessions
			this.#activeSessions.delete(sessionId);
		}

		// Clear ephemeral buffer if exists
		if (this.#ephemeralBuffers.has(sessionId)) {
			this.#ephemeralBuffers.delete(sessionId);
		}

		// Only do DB operations for persistent sessions
		if (!isEphemeral) {
			// Clear event recorder buffer
			try {
				this.#eventRecorder.clearBuffer(sessionId);
			} catch (error) {
				errors.push({ operation: 'clearBuffer', error });
				logger.warn('SESSION', `Error clearing buffer for ${sessionId}:`, error.message);
			}

			// Clear sequence counter
			try {
				this.#eventRecorder.eventStore.clearSequence(sessionId);
			} catch (error) {
				errors.push({ operation: 'clearSequence', error });
				logger.warn('SESSION', `Error clearing sequence for ${sessionId}:`, error.message);
			}

			// Update session status in DB
			try {
				await this.#sessionRepository.updateStatus(sessionId, 'stopped');
			} catch (error) {
				errors.push({ operation: 'updateStatus', error });
				logger.error('SESSION', `Failed to update status for ${sessionId}:`, error);
			}
		}

		// Emit session:closed event to all connected clients
		try {
			const io = getActiveSocketIO();
			if (io) {
				io.emit('session:closed', { sessionId });
				logger.debug('SESSION', `Emitted session:closed event for ${sessionId}`);
			}
		} catch (error) {
			errors.push({ operation: 'emitSocketEvent', error });
			logger.warn(
				'SESSION',
				`Error emitting session:closed event for ${sessionId}:`,
				error.message
			);
		}

		if (errors.length > 0) {
			logger.warn('SESSION', `Closed session ${sessionId} with ${errors.length} error(s)`, {
				errors
			});
		} else {
			logger.info(
				'SESSION',
				`Closed ${isEphemeral ? 'ephemeral' : 'persistent'} session: ${sessionId}`
			);
		}
	}

	/**
	 * Resume a stopped session (restart the process with same sessionId)
	 * NOTE: Only works for persistent sessions. Ephemeral sessions cannot be resumed.
	 *
	 * @param {string} sessionId - Session ID
	 * @returns {Promise<Object>} Resume result
	 */
	async resumeSession(sessionId) {
		// Check if it's an ephemeral session ID pattern (can't resume those)
		if (sessionId.startsWith('terminal_') || sessionId.startsWith('file-editor_')) {
			return {
				sessionId,
				resumed: false,
				reason: 'Ephemeral sessions cannot be resumed. Create a new window instead.'
			};
		}

		const session = await this.#sessionRepository.findById(sessionId);
		if (!session) {
			throw new Error(`Session not found: ${sessionId}`);
		}

		// Check database status to prevent race condition with closeSession
		if (session.status === 'running') {
			return { sessionId, resumed: false, reason: 'Already running in database' };
		}

		if (this.#activeSessions.has(sessionId)) {
			return { sessionId, resumed: false, reason: 'Already active in memory' };
		}

		let process = null;
		let cleanupRequired = false;

		try {
			// Start buffering
			this.#eventRecorder.startBuffering(sessionId);
			cleanupRequired = true;

			const adapter = this.#adapterRegistry.getAdapter(session.kind);

			// Parse metadata
			const metadata =
				typeof session.metadata === 'string' ? JSON.parse(session.metadata) : session.metadata;

			// Create process with error-handled onEvent callback
			process = await adapter.create({
				...metadata,
				onEvent: (/** @type {any} */ ev) => {
					this.#eventRecorder.recordEvent(sessionId, ev).catch((err) => {
						logger.error('SESSION', `Event recording failed for ${sessionId}:`, err);
					});
				}
			});

			this.#activeSessions.set(sessionId, {
				adapter,
				process,
				kind: session.kind,
				isEphemeral: false,
				cwd: metadata.cwd
			});

			// Flush buffered events
			await this.#eventRecorder.flushBuffer(sessionId);

			// Update status
			await this.#sessionRepository.updateStatus(sessionId, 'running');

			// Successfully resumed - no cleanup needed
			cleanupRequired = false;

			// Get recent events for replay context
			const recentEvents = await this.#eventRecorder.getEvents(sessionId, 0);
			const last10 = recentEvents.slice(-10);

			logger.info('SESSION', `Resumed ${session.kind} session: ${sessionId}`);

			return {
				sessionId,
				resumed: true,
				kind: session.kind,
				recentEventsCount: last10.length
			};
		} catch (error) {
			logger.error('SESSION', `Failed to resume ${sessionId}:`, error);
			throw error;
		} finally {
			// Cleanup on error using safe cleanup method
			if (cleanupRequired) {
				await this.#safeCleanup(sessionId, process, false);
			}
		}
	}

	/**
	 * Get active session process
	 * @param {string} sessionId - Session ID
	 * @returns {Object|null} Active session process or null
	 */
	getActiveProcess(sessionId) {
		const activeSession = this.#activeSessions.get(sessionId);
		return activeSession?.process || null;
	}

	/**
	 * Get all active session IDs
	 * @returns {Array<string>} List of active session IDs
	 */
	getActiveSessions() {
		return Array.from(this.#activeSessions.keys());
	}

	/**
	 * Get statistics about current state
	 * @returns {Object} Stats object
	 */
	getStats() {
		const sessions = Array.from(this.#activeSessions.values());
		const ephemeralCount = sessions.filter((s) => s.isEphemeral).length;
		const persistentCount = sessions.filter((s) => !s.isEphemeral).length;

		return {
			activeSessions: this.#activeSessions.size,
			ephemeralSessions: ephemeralCount,
			persistentSessions: persistentCount,
			ephemeralBuffers: this.#ephemeralBuffers.size,
			registeredAdapters: this.#adapterRegistry.getRegisteredTypes().length,
			supportedKinds: this.#adapterRegistry.getRegisteredTypes()
		};
	}

	/**
	 * Get all active ephemeral sessions
	 * @returns {Array<Object>} List of ephemeral session info
	 */
	getEphemeralSessions() {
		const ephemeral = [];
		for (const [sessionId, session] of this.#activeSessions.entries()) {
			if (session.isEphemeral) {
				ephemeral.push({
					id: sessionId,
					kind: session.kind,
					cwd: session.cwd,
					status: 'running'
				});
			}
		}
		return ephemeral;
	}

	/**
	 * Check if a session is ephemeral
	 * @param {string} sessionId - Session ID
	 * @returns {boolean} True if ephemeral
	 */
	isEphemeralSession(sessionId) {
		const session = this.#activeSessions.get(sessionId);
		return session?.isEphemeral ?? false;
	}

	/**
	 * Safely cleanup resources on error without throwing
	 * Collects all errors and logs them, but never throws
	 * @param {string} sessionId - Session ID to cleanup
	 * @param {Object|null} process - Process to close (if created)
	 * @param {boolean} [isEphemeral=false] - Whether this is an ephemeral session
	 * @returns {Promise<void>}
	 */
	async #safeCleanup(sessionId, process, isEphemeral = false) {
		const errors = [];

		// Close process if it was created
		if (process) {
			try {
				if (typeof process.close === 'function') {
					process.close();
				}
			} catch (err) {
				errors.push({ operation: 'process.close', error: err });
			}
		}

		// Remove from active sessions map
		try {
			this.#activeSessions.delete(sessionId);
		} catch (err) {
			errors.push({ operation: 'activeSessions.delete', error: err });
		}

		// Clear ephemeral buffer if exists
		if (this.#ephemeralBuffers.has(sessionId)) {
			this.#ephemeralBuffers.delete(sessionId);
		}

		// Only do DB operations for persistent sessions
		if (!isEphemeral) {
			// Update session status to error
			try {
				await this.#sessionRepository.updateStatus(sessionId, 'error');
			} catch (err) {
				errors.push({ operation: 'updateStatus', error: err });
			}

			// Clear event recorder buffer
			try {
				this.#eventRecorder.clearBuffer(sessionId);
			} catch (err) {
				errors.push({ operation: 'clearBuffer', error: err });
			}
		}

		// Log all errors encountered during cleanup
		if (errors.length > 0) {
			logger.error('SESSION', `Cleanup errors for ${sessionId}:`, errors);
		}
	}

	/**
	 * Cleanup all active sessions (useful for shutdown)
	 * @returns {Promise<void>}
	 */
	async cleanup() {
		const sessionIds = Array.from(this.#activeSessions.keys());

		await Promise.all(
			sessionIds.map((sessionId) =>
				this.closeSession(sessionId).catch((err) =>
					logger.warn('SESSION', `Failed to close ${sessionId} during cleanup:`, err)
				)
			)
		);

		logger.info('SESSION', 'SessionOrchestrator cleanup complete');
	}

	/**
	 * TEST ONLY: Set active sessions for testing
	 * @internal
	 * @param {Map} sessions - Map of sessionId -> { adapter, process }
	 */
	_setActiveSessions(sessions) {
		for (const [sessionId, session] of sessions.entries()) {
			this.#activeSessions.set(sessionId, session);
		}
	}

	/**
	 * TEST ONLY: Clear all active sessions
	 * @internal
	 */
	_clearActiveSessions() {
		this.#activeSessions.clear();
	}
}
