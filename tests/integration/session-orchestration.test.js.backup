/**
 * Session Orchestration Integration Tests
 *
 * Tests the full session lifecycle integration:
 * - Session creation through RunSessionManager
 * - Event persistence through EventRecorder
 * - Real-time event emission through Socket.IO
 * - Multi-client synchronization
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { RunSessionManager } from '$lib/server/runtime/RunSessionManager.js';
import { SessionRepository } from '$lib/server/database/SessionRepository.js';
import { EventRecorder } from '$lib/server/sessions/EventRecorder.js';
import { SessionId } from '$lib/server/sessions/SessionId.js';
import Database from 'better-sqlite3';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

describe('Session Orchestration Integration', () => {
	let db;
	let sessionRepository;
	let eventRecorder;
	let sessionManager;
	let testDbPath;

	beforeEach(() => {
		// Create test database
		testDbPath = join(__dirname, `../test-integration-${Date.now()}.db`);
		db = new Database(testDbPath);

		// Create tables
		db.exec(`
			CREATE TABLE IF NOT EXISTS sessions (
				runId TEXT PRIMARY KEY,
				kind TEXT NOT NULL,
				status TEXT NOT NULL,
				name TEXT,
				metadata TEXT,
				createdAt INTEGER NOT NULL,
				updatedAt INTEGER NOT NULL
			);

			CREATE TABLE IF NOT EXISTS session_events (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				runId TEXT NOT NULL,
				seq INTEGER NOT NULL,
				channel TEXT NOT NULL,
				type TEXT NOT NULL,
				payload TEXT,
				timestamp INTEGER NOT NULL,
				FOREIGN KEY (runId) REFERENCES sessions(runId)
			);
		`);

		// Initialize components
		sessionRepository = new SessionRepository({ db });
		eventRecorder = new EventRecorder({ db });

		// Create session manager (without actual adapters for testing)
		sessionManager = new RunSessionManager({
			sessionRepository,
			eventRecorder
		});
	});

	afterEach(() => {
		// Cleanup
		if (db) {
			db.close();
		}
		if (fs.existsSync(testDbPath)) {
			fs.unlinkSync(testDbPath);
		}
	});

	it('should create session and persist metadata', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running',
			name: 'Test Session',
			metadata: { cwd: '/workspace' }
		});

		const session = await sessionRepository.getByRunId(sessionId);

		expect(session).toBeTruthy();
		expect(session.runId).toBe(sessionId);
		expect(session.kind).toBe('pty');
		expect(session.status).toBe('running');
		expect(session.name).toBe('Test Session');
		expect(session.metadata).toEqual({ cwd: '/workspace' });
	});

	it('should persist session events with sequence numbers', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running',
			name: 'Event Test'
		});

		// Record events
		await eventRecorder.recordEvent(sessionId, {
			channel: 'pty:stdout',
			type: 'chunk',
			payload: Buffer.from('output 1')
		});

		await eventRecorder.recordEvent(sessionId, {
			channel: 'pty:stdout',
			type: 'chunk',
			payload: Buffer.from('output 2')
		});

		await eventRecorder.recordEvent(sessionId, {
			channel: 'system:status',
			type: 'closed',
			payload: { exitCode: 0 }
		});

		// Retrieve events
		const events = await eventRecorder.getEventsSince(sessionId, 0);

		expect(events).toHaveLength(3);
		expect(events[0].seq).toBe(1);
		expect(events[1].seq).toBe(2);
		expect(events[2].seq).toBe(3);
		expect(events[0].channel).toBe('pty:stdout');
		expect(events[2].channel).toBe('system:status');
	});

	it('should support event replay from specific sequence', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running'
		});

		// Record 5 events
		for (let i = 1; i <= 5; i++) {
			await eventRecorder.recordEvent(sessionId, {
				channel: 'pty:stdout',
				type: 'chunk',
				payload: Buffer.from(`output ${i}`)
			});
		}

		// Replay from sequence 3
		const events = await eventRecorder.getEventsSince(sessionId, 3);

		expect(events).toHaveLength(2);
		expect(events[0].seq).toBe(4);
		expect(events[1].seq).toBe(5);
	});

	it('should handle session status transitions', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running'
		});

		let session = await sessionRepository.getByRunId(sessionId);
		expect(session.status).toBe('running');

		// Transition to closed
		await sessionRepository.updateStatus(sessionId, 'closed');

		session = await sessionRepository.getByRunId(sessionId);
		expect(session.status).toBe('closed');
	});

	it('should support concurrent event recording', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running'
		});

		// Record events concurrently
		await Promise.all([
			eventRecorder.recordEvent(sessionId, {
				channel: 'pty:stdout',
				type: 'chunk',
				payload: Buffer.from('concurrent 1')
			}),
			eventRecorder.recordEvent(sessionId, {
				channel: 'pty:stdout',
				type: 'chunk',
				payload: Buffer.from('concurrent 2')
			}),
			eventRecorder.recordEvent(sessionId, {
				channel: 'pty:stdout',
				type: 'chunk',
				payload: Buffer.from('concurrent 3')
			})
		]);

		const events = await eventRecorder.getEventsSince(sessionId, 0);

		// All events should be recorded with unique sequence numbers
		expect(events).toHaveLength(3);
		expect(events[0].seq).toBe(1);
		expect(events[1].seq).toBe(2);
		expect(events[2].seq).toBe(3);
	});

	it('should list sessions by status', async () => {
		// Create multiple sessions
		const runningId1 = SessionId.generate('pty');
		const runningId2 = SessionId.generate('pty');
		const closedId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: runningId1,
			kind: 'pty',
			status: 'running',
			name: 'Running 1'
		});

		await sessionRepository.create({
			runId: runningId2,
			kind: 'pty',
			status: 'running',
			name: 'Running 2'
		});

		await sessionRepository.create({
			runId: closedId,
			kind: 'pty',
			status: 'closed',
			name: 'Closed'
		});

		const sessions = await sessionRepository.listSessions();

		expect(sessions).toHaveLength(3);

		const running = sessions.filter(s => s.status === 'running');
		const closed = sessions.filter(s => s.status === 'closed');

		expect(running).toHaveLength(2);
		expect(closed).toHaveLength(1);
	});

	it('should handle session with large event history', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running'
		});

		// Record 1000 events
		for (let i = 1; i <= 1000; i++) {
			await eventRecorder.recordEvent(sessionId, {
				channel: 'pty:stdout',
				type: 'chunk',
				payload: Buffer.from(`line ${i}\n`)
			});
		}

		// Retrieve all events
		const allEvents = await eventRecorder.getEventsSince(sessionId, 0);
		expect(allEvents).toHaveLength(1000);

		// Retrieve recent events
		const recentEvents = await eventRecorder.getEventsSince(sessionId, 990);
		expect(recentEvents).toHaveLength(10);
		expect(recentEvents[0].seq).toBe(991);
	});
});

describe('Session Orchestration - Error Handling', () => {
	let db;
	let sessionRepository;
	let eventRecorder;
	let testDbPath;

	beforeEach(() => {
		testDbPath = join(__dirname, `../test-integration-${Date.now()}.db`);
		db = new Database(testDbPath);

		db.exec(`
			CREATE TABLE IF NOT EXISTS sessions (
				runId TEXT PRIMARY KEY,
				kind TEXT NOT NULL,
				status TEXT NOT NULL,
				name TEXT,
				metadata TEXT,
				createdAt INTEGER NOT NULL,
				updatedAt INTEGER NOT NULL
			);

			CREATE TABLE IF NOT EXISTS session_events (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				runId TEXT NOT NULL,
				seq INTEGER NOT NULL,
				channel TEXT NOT NULL,
				type TEXT NOT NULL,
				payload TEXT,
				timestamp INTEGER NOT NULL,
				FOREIGN KEY (runId) REFERENCES sessions(runId)
			);
		`);

		sessionRepository = new SessionRepository({ db });
		eventRecorder = new EventRecorder({ db });
	});

	afterEach(() => {
		if (db) {
			db.close();
		}
		if (fs.existsSync(testDbPath)) {
			fs.unlinkSync(testDbPath);
		}
	});

	it('should reject duplicate session IDs', async () => {
		const sessionId = SessionId.generate('pty');

		await sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running'
		});

		// Try to create duplicate
		await expect(sessionRepository.create({
			runId: sessionId,
			kind: 'pty',
			status: 'running'
		})).rejects.toThrow();
	});

	it('should handle missing session for event recording', async () => {
		const nonExistentId = SessionId.generate('pty');

		// Recording event for non-existent session might throw or silently fail
		// depending on implementation
		await expect(eventRecorder.recordEvent(nonExistentId, {
			channel: 'pty:stdout',
			type: 'chunk',
			payload: Buffer.from('orphan event')
		})).rejects.toThrow();
	});

	it('should handle invalid session ID format', async () => {
		const invalidId = 'not-a-valid-session-id';

		await expect(sessionRepository.getByRunId(invalidId))
			.rejects.toThrow();
	});
});
